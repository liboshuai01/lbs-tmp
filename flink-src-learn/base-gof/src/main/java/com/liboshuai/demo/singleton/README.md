# 单例模式实现

这个目录包含了Java中单例（Singleton）设计模式的多种实现方式。这些示例展示了如何确保一个类只有一个实例，并提供一个全局访问点。

下面是此目录中每种实现的摘要。

---

### 1. 饿汉式（静态变量）
- **文件:** `Singleton1.java`
- **描述:** 这是一种饿汉式初始化方法，实例在类加载时就被创建。这种方法简单且天然线程安全。
- **关键特性:** `INSTANCE` 是一个 `static final` 变量，在声明时直接初始化。

---

### 2. 饿汉式（静态代码块）
- **文件:** `Singleton2.java`
- **描述:** 与静态变量方式类似，此实现使用静态代码块来初始化实例。如果实例化过程中需要处理异常或执行其他逻辑，这种方式会很有用。
- **关键特性:** `INSTANCE` 在一个 `static` 代码块中被创建。

---

### 3. 懒汉式（线程不安全）
- **文件:** `Singleton3.java`
- **描述:** 这是一种“懒汉式”实现，实例仅在 `getInstance()` 方法首次被调用时创建。
- **警告:** 这个版本是 **线程不安全** 的。如果多个线程同时进入 `if (instance == null)` 判断，可能会导致创建多个不同的实例。

---

### 4. 懒汉式（`synchronized` 方法，线程安全）
- **文件:** `Singleton4.java`
- **描述:** 这个版本通过在 `getInstance()` 方法上添加 `synchronized` 关键字来保证线程安全。
- **缺点:** 在多线程竞争激烈的环境下，性能会比较低下，因为每个线程每次调用都需要获取和释放锁。

---

### 5. 懒汉式（双重检查锁定，Double-Checked Locking）
- **文件:** `Singleton5.java`
- **描述:** 这是一种经过优化的线程安全的懒汉式实现。它通过 `synchronized` 代码块减小了锁的范围，并使用 `volatile` 关键字来防止指令重排序，确保多线程环境下 `instance` 变量的可见性，避免获取到未完全初始化的对象。
- **关键特性:**
    - 使用 `volatile` 修饰实例变量。
    - 通过双重 `if (instance == null)` 检查，避免了在实例创建后不必要的同步开销。

---

### 6. 懒汉式（静态内部类）
- **文件:** `Singleton6.java`
- **描述:** 这是懒汉式初始化中被广泛推荐的一种实现方式。它利用了JVM的类加载机制：静态内部类只有在首次被使用时才会被加载。这既实现了懒加载，又无需显式同步即可保证线程安全。
- **关键特性:** 一个私有的静态内部类 `Singleton5Holder` 持有 `INSTANCE` 实例。

---

### 7. 枚举单例
- **文件:** `Singleton7.java`
- **描述:** 这通常被认为是实现单例模式最简洁、最稳健的方式。它天然地保证了线程安全和序列化安全，并且能有效防止通过反射进行攻击。
- **关键特性:** 将单例声明为一个只有一个实例的Java `enum`。

---

### 关于序列化处理

此目录中的所有实现（除枚举外）都包含了一个 `readResolve()` 方法。这个方法对于在序列化和反序列化场景下维持单例特性至关重要。`readResolve()` 方法可以确保在反序列化时返回已存在的单例实例，而不是创建一个新的实例。
